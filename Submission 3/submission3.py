# -*- coding: utf-8 -*-
"""Submission3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SAaVeChGhr_vmphGAcyl0C24ZiAtA8Vu

# Machine Learning Development Project: Submission 3
## Animal Image Classification
### Dataset: [Animals-10](https://www.kaggle.com/datasets/alessiocorrado99/animals10/data)
- Nama: Nabila Jauza Firjatullah
- Email: nabila060695@gmail.com
- Id Dicoding: billa_firza
"""

# Connect to Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Import library
import os
import shutil
import zipfile
from PIL import Image
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization, Activation
from tensorflow.keras.callbacks import Callback, ReduceLROnPlateau
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.applications import ResNet50V2
from sklearn.metrics import confusion_matrix, classification_report

# Unzip folder

# Define folder path
zip_file_path = '/content/drive/MyDrive/IDCamp2023/Pengembangan ML/Animal Classification/animal.zip'

# Define folder path for unzip folder
extracted_folder = '/content/drive/MyDrive/IDCamp2023/Pengembangan ML/Animal Classification/Animals'

# Create a ZipFile object
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    # Extract all the contents into the specified folder
    zip_ref.extractall(extracted_folder)

# Define folder where to see image category
folder_path = '/content/drive/MyDrive/IDCamp2023/Pengembangan ML/Animal Classification/Animals'

# List all files in the folder
files = os.listdir(folder_path)

# Print the names of all files
for file in files:
    print(file)

# Function to check image resolution
def display_image_sizes(folder_path, category):
    print(f"\nOriginal sizes of the first 5 images from the {category} folder:")

    # List all files in the folder
    image_files = os.listdir(os.path.join(folder_path, category))

    # Take the first 5 images
    selected_images = image_files[:5]

    # Display the original sizes of each image
    for image_name in selected_images:
        image_path = os.path.join(folder_path, category, image_name)
        image = Image.open(image_path)
        original_size = image.size
        print(f"Original size of the image {image_name}: {original_size}")

for file in files:
    display_image_sizes(folder_path, file)

# Display the images
def display_image(folder_path, category):
    image_files = os.listdir(os.path.join(folder_path, category))

    # Take the first 5 images
    selected_images = image_files[:5]

    # Display the images in a horizontal 5x2 grid
    plt.figure(figsize=(15, 7))
    for i, image_name in enumerate(selected_images, 1):
        image_path = os.path.join(folder_path, category, image_name)
        image = Image.open(image_path)
        plt.subplot(2, 5, i)
        plt.imshow(image)
        plt.title(f"Image {i}")
        plt.axis("off")

    plt.suptitle(category.capitalize(), fontsize=15)
    plt.show()

for file in files:
    display_image(folder_path, file)

# Total Image
total_images = 0
for animal in files:
    images = len(os.listdir(f'{folder_path}/{animal}'))
    print(f'{animal} images: ', images)
    total_images += images
print("---------------------")
print (f'Total Images : {total_images}')

# Train data image generator
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=0.2,
    zoom_range=0.2,
    brightness_range=[0.8, 1.2],
    horizontal_flip=True,  # Random horizontal flipping of images
    validation_split=0.2
)

# Validation data image generator
validation_datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2
)

# Set up data generator for training
train_generator = train_datagen.flow_from_directory(
    folder_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='training',
    shuffle=True,
    seed=42
)

# Set up data generator for validation
validation_generator = validation_datagen.flow_from_directory(
    folder_path,
    target_size=(224, 224),
    batch_size=1,
    class_mode='categorical',
    subset='validation',
    shuffle=False
)

# Display the class indices
print("Class Indices:", train_generator.class_indices)

base_model = ResNet50V2(
    input_shape=(224, 224, 3),
    include_top=False,
    pooling='max'
)

for layer in base_model.layers:
    layer.trainable = False

base_model.summary()

# Create a Sequential model
model = Sequential()
model.add(base_model)
model.add(Dense(5, activation='softmax'))

model.compile(loss='categorical_crossentropy',
              optimizer=Adam(learning_rate=0.001),
              metrics=['accuracy'])

model.summary()

reduce_lr = ReduceLROnPlateau(
    monitor='val_loss',
    patience=3,
    factor=0.2,
    min_lr=0.0000015
)

# Callback
class myCallback(Callback):
    def on_epoch_end(self, epoch, logs={}):
        if(logs.get('accuracy') > 0.92
           and logs.get('val_accuracy') > 0.92):
            self.model.stop_training = True
            print("\nAccuracy is sufficient > 92%!")

callbacks = myCallback()

# Train the model
history = model.fit(
    train_generator,
    epochs=100,
    validation_data=validation_generator,
    verbose=1,
    callbacks=[callbacks, reduce_lr]
)

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(len(acc))

# Plot training and validation accuracy
plt.plot(epochs, acc, 'r', label='Training Accuracy')
plt.plot(epochs, val_acc, 'b', label='Validation Accuracy')

# Plot training and validation loss
plt.plot(epochs, loss, 'g', label='Training Loss')
plt.plot(epochs, val_loss, 'y', label='Validation Loss')

plt.title('Training and Validation Accuracy/Loss')
plt.legend(loc=0)
plt.figure()
plt.show()

true_labels = validation_generator.classes

num_samples = len(validation_generator.classes)

predictions = model.predict(validation_generator, steps=np.ceil(num_samples / validation_generator.batch_size), verbose=1)

predicted_labels = np.argmax(predictions, axis=1)

conf_matrix = confusion_matrix(true_labels[:num_samples], predicted_labels)

print("Confusion Matrix:")
print(conf_matrix)

print("\nClassification Report:")
print(classification_report(true_labels[:num_samples], predicted_labels, target_names=validation_generator.class_indices.keys()))

# Convert the Keras model to TensorFlow Lite format
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

# Save the TensorFlow Lite model to a file
with tf.io.gfile.GFile('animals-6.tflite', 'wb') as f:
    f.write(tflite_model)

tf.saved_model.save(model,'content/')

"""Testing Model"""

filenames = validation_generator.filenames

class_indices = validation_generator.class_indices
indices = {v:k for k,v in class_indices.items()}

val_df = pd.DataFrame()
val_df['filename'] = filenames

val_df['actual'] = true_labels

val_df['predicted'] = predicted_labels

val_df['actual'] = val_df['actual'].apply(lambda x: indices[x])
val_df['predicted'] = val_df['predicted'].apply(lambda x: indices[x])

val_df.loc[val_df['actual'] == val_df['predicted'], 'PredictionMatch'] = True
val_df.loc[val_df['actual'] != val_df['predicted'], 'PredictionMatch'] = False

val_df = val_df.sample(frac=1).reset_index(drop=True)

val_df.head(10)

# Function to read an image from the given path
def read_image(path):
    img = load_img(path, color_mode='rgb', target_size=(224, 224))
    img = img_to_array(img)
    img = img / 255.

    return img

def display_images(temp_df):
    temp_df = temp_df.reset_index(drop=True)
    plt.figure(figsize=(20, 20))
    n = 0

    for i in range(20):
        n += 1
        plt.subplot(5, 5, n)
        plt.subplots_adjust(hspace=0.5, wspace=0.3)
        image = read_image(f"/content/drive/MyDrive/IDCamp2023/Pengembangan ML/Animal Classification/Animals/{temp_df.filename[i]}")
        plt.imshow(image)
        plt.title(f'A: {temp_df.actual[i]} P: {temp_df.predicted[i]}')

display_images(val_df[val_df['PredictionMatch']==True])

display_images(val_df[val_df['PredictionMatch']==False])